<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: hub.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: hub.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __importStar = (this &amp;&amp; this.__importStar) || function (mod) {
    if (mod &amp;&amp; mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const Consts = __importStar(require("./consts"));
const Debug = require("debug");
const debug = Debug("hub");
/**
 * @class Hub
 * @extends EventEmitter
 */
class Hub extends events_1.EventEmitter {
    constructor(peripheral, autoSubscribe = true) {
        super();
        this.autoSubscribe = true;
        this.useSpeedMap = true;
        this.type = Consts.HubType.UNKNOWN;
        this._ports = {};
        this._characteristics = {};
        this._firmwareInfo = { major: 0, minor: 0, bugFix: 0, build: 0 };
        this._batteryLevel = 100;
        this._rssi = -100;
        this.autoSubscribe = !!autoSubscribe;
        this._peripheral = peripheral;
        this._uuid = peripheral.uuid;
        this._name = peripheral.advertisement.localName;
    }
    /**
     * @readonly
     * @property {string} name Name of the hub
     */
    get name() {
        return this._name;
    }
    /**
     * @readonly
     * @property {string} firmwareVersion Firmware version of the hub
     */
    get firmwareVersion() {
        return `${this._firmwareInfo.major}.${this._firmwareInfo.minor}.${this._lpad(this._firmwareInfo.bugFix.toString(), 2)}.${this._lpad(this._firmwareInfo.build.toString(), 4)}`;
    }
    /**
     * @readonly
     * @property {string} uuid UUID of the hub
     */
    get uuid() {
        return this._uuid;
    }
    /**
     * @readonly
     * @property {number} rssi Signal strength of the hub
     */
    get rssi() {
        return this._rssi;
    }
    /**
     * @readonly
     * @property {number} batteryLevel Battery level of the hub (Percentage between 0-100)
     */
    get batteryLevel() {
        return this._batteryLevel;
    }
    /**
     * Connect to the Hub.
     * @method Hub#connect
     * @returns {Promise} Resolved upon successful connect.
     */
    connect() {
        return new Promise((connectResolve, connectReject) => {
            const self = this;
            this._peripheral.connect((err) => {
                this._rssi = this._peripheral.rssi;
                const rssiUpdateInterval = setInterval(() => {
                    this._peripheral.updateRssi((err, rssi) => {
                        if (!err) {
                            if (this._rssi !== rssi) {
                                this._rssi = rssi;
                            }
                        }
                    });
                }, 2000);
                self._peripheral.on("disconnect", () => {
                    clearInterval(rssiUpdateInterval);
                    this.emit("disconnect");
                });
                self._peripheral.discoverServices([], (err, services) => {
                    if (err) {
                        this.emit("error", err);
                        return;
                    }
                    debug("Service/characteristic discovery started");
                    const servicePromises = [];
                    services.forEach((service) => {
                        servicePromises.push(new Promise((resolve, reject) => {
                            service.discoverCharacteristics([], (err, characteristics) => {
                                characteristics.forEach((characteristic) => {
                                    this._characteristics[characteristic.uuid] = characteristic;
                                });
                                return resolve();
                            });
                        }));
                    });
                    Promise.all(servicePromises).then(() => {
                        debug("Service/characteristic discovery finished");
                        this.emit("connect");
                        return connectResolve();
                    });
                });
            });
        });
    }
    /**
     * Disconnect the Hub.
     * @method Hub#disconnect
     * @returns {Promise} Resolved upon successful disconnect.
     */
    disconnect() {
        return new Promise((resolve, reject) => {
            this._peripheral.disconnect(() => {
                return resolve();
            });
        });
    }
    /**
     * Subscribe to sensor notifications on a given port.
     * @method Hub#subscribe
     * @param {string} port
     * @param {number} [mode] The sensor mode to activate. If no mode is provided, the default for that sensor will be chosen.
     * @returns {Promise} Resolved upon successful issuance of command.
     */
    subscribe(port, mode) {
        return new Promise((resolve, reject) => {
            let newMode = this._getModeForDeviceType(this._portLookup(port).type);
            if (mode) {
                newMode = mode;
            }
            this._activatePortDevice(this._portLookup(port).value, this._portLookup(port).type, newMode, 0x00, () => {
                return resolve();
            });
        });
    }
    /**
     * Unsubscribe to sensor notifications on a given port.
     * @method Hub#unsubscribe
     * @param {string} port
     * @returns {Promise} Resolved upon successful issuance of command.
     */
    unsubscribe(port) {
        return new Promise((resolve, reject) => {
            const mode = this._getModeForDeviceType(this._portLookup(port).type);
            this._deactivatePortDevice(this._portLookup(port).value, this._portLookup(port).type, mode, 0x00, () => {
                return resolve();
            });
        });
    }
    /**
     * Sleep a given amount of time.
     *
     * This is a helper method to make it easier to add delays into a chain of commands.
     * @method Hub#sleep
     * @param {number} delay How long to sleep (in milliseconds).
     * @returns {Promise} Resolved after the delay is finished.
     */
    sleep(delay) {
        return new Promise((resolve) => {
            global.setTimeout(resolve, delay);
        });
    }
    /**
     * Wait until a given list of concurrently running commands are complete.
     *
     * This is a helper method to make it easier to wait for concurrent commands to complete.
     * @method Hub#wait
     * @param {Array&lt;Promise&lt;any>>} commands Array of executing commands.
     * @returns {Promise} Resolved after the commands are finished.
     */
    wait(commands) {
        return Promise.all(commands);
    }
    /**
     * Get the hub type.
     * @method Hub#getHubType
     * @returns {HubType}
     */
    getHubType() {
        return this.type;
    }
    /**
     * Get the device type for a given port.
     * @method Hub#getPortDeviceType
     * @param {string} port
     * @returns {DeviceType}
     */
    getPortDeviceType(port) {
        return this._portLookup(port).type;
    }
    _getCharacteristic(uuid) {
        return this._characteristics[uuid.replace(/-/g, "")];
    }
    _subscribeToCharacteristic(characteristic, callback) {
        characteristic.on("data", (data) => {
            return callback(data);
        });
        characteristic.subscribe((err) => {
            if (err) {
                this.emit("error", err);
            }
        });
    }
    _activatePortDevice(port, type, mode, format, callback) {
        if (callback) {
            callback();
        }
    }
    _deactivatePortDevice(port, type, mode, format, callback) {
        if (callback) {
            callback();
        }
    }
    _registerDeviceAttachment(port, type) {
        if (port.connected) {
            port.type = type;
            if (this.autoSubscribe) {
                this._activatePortDevice(port.value, type, this._getModeForDeviceType(type), 0x00);
                /**
                 * Emits when a motor or sensor is attached to the Hub.
                 * @event Hub#attach
                 * @param {string} port
                 * @param {DeviceType} type
                 */
                this.emit("attach", port.id, type);
            }
        }
        else {
            port.type = Consts.DeviceType.UNKNOWN;
            debug(`Port ${port.id} disconnected`);
            /**
             * Emits when an attached motor or sensor is detached from the Hub.
             * @event Hub#detach
             * @param {string} port
             */
            this.emit("detach", port.id);
        }
    }
    _getPortForPortNumber(num) {
        for (const key of Object.keys(this._ports)) {
            if (this._ports[key].value === num) {
                return this._ports[key];
            }
        }
        return false;
    }
    _mapSpeed(speed) {
        if (!this.useSpeedMap) {
            return speed;
        }
        if (speed === 127) {
            return 127; // Hard stop
        }
        if (speed > 100) {
            speed = 100;
        }
        else if (speed &lt; -100) {
            speed = -100;
        }
        return speed;
    }
    _calculateRamp(fromSpeed, toSpeed, time, port) {
        const emitter = new events_1.EventEmitter();
        const steps = Math.abs(toSpeed - fromSpeed);
        let delay = time / steps;
        let increment = 1;
        if (delay &lt; 50 &amp;&amp; steps > 0) {
            increment = 50 / delay;
            delay = 50;
        }
        if (fromSpeed > toSpeed) {
            increment = -increment;
        }
        let i = 0;
        const interval = setInterval(() => {
            let speed = Math.round(fromSpeed + (++i * increment));
            if (toSpeed > fromSpeed &amp;&amp; speed > toSpeed) {
                speed = toSpeed;
            }
            else if (fromSpeed > toSpeed &amp;&amp; speed &lt; toSpeed) {
                speed = toSpeed;
            }
            emitter.emit("changeSpeed", speed);
            if (speed === toSpeed) {
                clearInterval(interval);
                emitter.emit("finished");
            }
        }, delay);
        port.setEventTimer(interval);
        return emitter;
    }
    _portLookup(port) {
        if (!this._ports[port.toUpperCase()]) {
            throw new Error(`Port ${port.toUpperCase()} does not exist on this Hub type`);
        }
        return this._ports[port];
    }
    _lpad(str, length) {
        while (str.length &lt; length) {
            str = "0" + str;
        }
        return str;
    }
    _getModeForDeviceType(type) {
        switch (type) {
            case Consts.DeviceType.BASIC_MOTOR:
                return 0x02;
            case Consts.DeviceType.TRAIN_MOTOR:
                return 0x02;
            case Consts.DeviceType.BOOST_TACHO_MOTOR:
                return 0x02;
            case Consts.DeviceType.BOOST_MOVE_HUB_MOTOR:
                return 0x02;
            case Consts.DeviceType.BOOST_DISTANCE:
                return (this.type === Consts.HubType.WEDO2_SMART_HUB ? 0x00 : 0x08);
            case Consts.DeviceType.BOOST_TILT:
                return 0x04;
            default:
                return 0x00;
        }
    }
}
exports.Hub = Hub;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BoostMoveHub.html">BoostMoveHub</a></li><li><a href="DuploTrainBase.html">DuploTrainBase</a></li><li><a href="Hub.html">Hub</a></li><li><a href="LPF2Hub.html">LPF2Hub</a></li><li><a href="PoweredUP.html">PoweredUP</a></li><li><a href="PUPHub.html">PUPHub</a></li><li><a href="PUPRemote.html">PUPRemote</a></li><li><a href="WeDo2SmartHub.html">WeDo2SmartHub</a></li></ul><h3>Events</h3><ul><li><a href="BoostMoveHub.html#event:attach">attach</a></li><li><a href="BoostMoveHub.html#event:button">button</a></li><li><a href="BoostMoveHub.html#event:color">color</a></li><li><a href="BoostMoveHub.html#event:colorAndDistance">colorAndDistance</a></li><li><a href="BoostMoveHub.html#event:detach">detach</a></li><li><a href="BoostMoveHub.html#event:distance">distance</a></li><li><a href="BoostMoveHub.html#event:rotate">rotate</a></li><li><a href="BoostMoveHub.html#event:tilt">tilt</a></li><li><a href="DuploTrainBase.html#event:color">color</a></li><li><a href="DuploTrainBase.html#event:speed">speed</a></li><li><a href="Hub.html#event:attach">attach</a></li><li><a href="Hub.html#event:detach">detach</a></li><li><a href="LPF2Hub.html#event:attach">attach</a></li><li><a href="LPF2Hub.html#event:button">button</a></li><li><a href="LPF2Hub.html#event:color">color</a></li><li><a href="LPF2Hub.html#event:colorAndDistance">colorAndDistance</a></li><li><a href="LPF2Hub.html#event:detach">detach</a></li><li><a href="LPF2Hub.html#event:distance">distance</a></li><li><a href="LPF2Hub.html#event:rotate">rotate</a></li><li><a href="LPF2Hub.html#event:speed">speed</a></li><li><a href="LPF2Hub.html#event:tilt">tilt</a></li><li><a href="PoweredUP.html#event:discover">discover</a></li><li><a href="PUPHub.html#event:attach">attach</a></li><li><a href="PUPHub.html#event:button">button</a></li><li><a href="PUPHub.html#event:color">color</a></li><li><a href="PUPHub.html#event:colorAndDistance">colorAndDistance</a></li><li><a href="PUPHub.html#event:detach">detach</a></li><li><a href="PUPHub.html#event:distance">distance</a></li><li><a href="PUPHub.html#event:tilt">tilt</a></li><li><a href="PUPRemote.html#event:button">button</a></li><li><a href="PUPRemote.html#event:colorAndDistance">colorAndDistance</a></li><li><a href="WeDo2SmartHub.html#event:attach">attach</a></li><li><a href="WeDo2SmartHub.html#event:button">button</a></li><li><a href="WeDo2SmartHub.html#event:color">color</a></li><li><a href="WeDo2SmartHub.html#event:detach">detach</a></li><li><a href="WeDo2SmartHub.html#event:distance">distance</a></li><li><a href="WeDo2SmartHub.html#event:rotate">rotate</a></li><li><a href="WeDo2SmartHub.html#event:tilt">tilt</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Jan 18 2019 16:16:36 GMT-0800 (Pacific Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
